// -------------------------------------------------------------
// 
// File Name: hdlsrc\DUC\Carrier_2.v
// Created: 2025-04-03 15:54:05
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Carrier_2
// Source Path: DUC/AM_MultiBaseband_module/Carry2/Carrier_2
// Hierarchy Level: 2
// Model version: 3.93
// 
// NCO
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Carrier_2
          (clk,
           rst_n,
           enb,
           inc,
           validIn,
           sine);


  input   clk;
  input   rst_n;
  input   enb;
  input   [31:0] inc;  // uint32
  input   validIn;
  output  signed [15:0] sine;  // sfix16_En15


  reg  [4:0] outsel_reg_reg;  // ufix1 [5]
  wire outsel;
  wire signed [15:0] outzero;  // sfix16_En15
  wire signed [27:0] const0;  // sfix28
  wire signed [27:0] pInc;  // sfix28
  wire signed [27:0] validPInc;  // sfix28
  reg signed [27:0] accphase_reg;  // sfix28
  wire signed [27:0] addpInc;  // sfix28
  wire signed [27:0] pOffset;  // sfix28
  wire signed [27:0] accoffset;  // sfix28
  reg signed [27:0] accoffsete_reg;  // sfix28
  wire [14:0] dither;  // ufix15
  wire signed [27:0] casteddither;  // sfix28
  reg signed [27:0] dither_reg;  // sfix28
  wire signed [27:0] accumulator;  // sfix28
  wire [12:0] accQuantized;  // ufix13_E15
  wire signed [15:0] outs;  // sfix16_En15
  wire signed [15:0] validouts;  // sfix16_En15
  reg signed [15:0] sine_1;  // sfix16_En15


  always @(posedge clk)
    begin : outsel_reg_process
      if (rst_n == 1'b0) begin
        outsel_reg_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          outsel_reg_reg[0] <= validIn;
          outsel_reg_reg[32'sd4:32'sd1] <= outsel_reg_reg[32'sd3:32'sd0];
        end
      end
    end

  assign outsel = outsel_reg_reg[4];

  assign outzero = 16'sb0000000000000000;

  // Constant Zero
  assign const0 = 28'sb0000000000000000000000000000;

  assign pInc = $signed(inc[27:0]);

  assign validPInc = (validIn == 1'b0 ? const0 :
              pInc);

  // Add phase increment
  assign addpInc = accphase_reg + validPInc;

  // Phase increment accumulator register
  always @(posedge clk)
    begin : AccPhaseRegister_process
      if (rst_n == 1'b0) begin
        accphase_reg <= 28'sb0000000000000000000000000000;
      end
      else begin
        if (enb) begin
          accphase_reg <= addpInc;
        end
      end
    end

  assign pOffset = 28'sb0000000000000000000000000000;

  // Add phase offset
  assign accoffset = accphase_reg + pOffset;

  // Phase offset accumulator register
  always @(posedge clk)
    begin : AccOffsetRegister_process
      if (rst_n == 1'b0) begin
        accoffsete_reg <= 28'sb0000000000000000000000000000;
      end
      else begin
        if (enb) begin
          accoffsete_reg <= accoffset;
        end
      end
    end

  DitherGen_block u_dither_inst (.clk(clk),
                                 .rst_n(rst_n),
                                 .enb(enb),
                                 .validIn(validIn),
                                 .dither(dither)  // ufix15
                                 );

  assign casteddither = {13'b0, dither};

  // Dither input register
  always @(posedge clk)
    begin : DitherRegister_process
      if (rst_n == 1'b0) begin
        dither_reg <= 28'sb0000000000000000000000000000;
      end
      else begin
        if (enb) begin
          dither_reg <= casteddither;
        end
      end
    end

  // Add dither
  assign accumulator = accoffsete_reg + dither_reg;

  // Phase quantization
  assign accQuantized = accumulator[27:15];

  WaveformGen_block u_Wave_inst (.clk(clk),
                                 .rst_n(rst_n),
                                 .enb(enb),
                                 .phaseIdx(accQuantized),  // ufix13_E15
                                 .sine(outs)  // sfix16_En15
                                 );

  assign validouts = (outsel == 1'b0 ? outzero :
              outs);

  // Output register
  always @(posedge clk)
    begin : OutputRegister_process
      if (rst_n == 1'b0) begin
        sine_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          sine_1 <= validouts;
        end
      end
    end

  assign sine = sine_1;

endmodule  // Carrier_2

