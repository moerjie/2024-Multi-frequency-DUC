// -------------------------------------------------------------
// 
// File Name: hdlsrc\DUC\Painter.v
// Created: 2025-01-12 11:22:58
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Painter
// Source Path: DUC/Signal_Source_module/Painter
// Hierarchy Level: 1
// Model version: 3.30
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Painter
          (clk,
           rst_n,
           enb,
           SIGNAL,
           VLD);


  input   clk;
  input   rst_n;
  input   enb;
  output  signed [15:0] SIGNAL;  // sfix16_En15
  output  VLD;


  wire signed [15:0] kconst;  // sfix16_En15
  reg signed [15:0] kconst_1;  // sfix16_En15
  wire [31:0] Constant2_out1;  // uint32
  wire [7:0] Constant1_out1;  // uint8
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from_1;  // uint16
  reg [15:0] Counter_Limited_out1;  // uint16
  wire [15:0] count;  // uint16
  wire needToWrap;
  wire [15:0] count_value;  // uint16
  wire [15:0] Constant_out1;  // uint16
  wire Relational_Operator_out1;
  wire [15:0] count_step_1;  // uint16
  wire [15:0] count_from_2;  // uint16
  reg [15:0] HDL_Counter1_out1;  // uint16
  wire [15:0] count_1;  // uint16
  wire need_to_wrap;
  wire [15:0] count_value_1;  // uint16
  wire [15:0] count_2;  // uint16
  wire [15:0] Constant4_out1;  // uint16
  wire Relational_Operator2_out1;
  wire [7:0] count_step_2;  // uint8
  wire [7:0] count_from_3;  // uint8
  reg [7:0] HDL_Counter_out1;  // uint8
  wire [7:0] count_3;  // uint8
  wire need_to_wrap_1;
  wire [7:0] count_value_2;  // uint8
  wire [7:0] count_4;  // uint8
  wire [7:0] Single_Port_RAM_System_out1;  // uint8
  wire [31:0] Single_Port_RAM_System1_out1;  // uint32
  wire NCO_VLD_out1;
  wire signed [15:0] NCO_out1;  // sfix16_En15
  wire NCO_out2;
  reg signed [15:0] NCO_out1_1;  // sfix16_En15
  wire signed [31:0] Gain2_mul_temp;  // sfix32_En30
  wire signed [15:0] Gain2_out1;  // sfix16_En15
  reg signed [15:0] Gain2_out1_1;  // sfix16_En15


  assign kconst = 16'sb0111100110011010;

  always @(posedge clk)
    begin : HwModeRegister_process
      if (rst_n == 1'b0) begin
        kconst_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end

  assign Constant2_out1 = 32'b00000000000000000000000000000000;
  assign Constant1_out1 = 8'b00000000;
  assign count_step = 16'b0000000000000001;
  assign count_from_1 = 16'b0000000000000000;
  assign count = Counter_Limited_out1 + count_step;
  assign needToWrap = Counter_Limited_out1 >= 16'b0000100111000011;
  assign count_value = (needToWrap == 1'b0 ? count :
              count_from_1);
  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2499
  always @(posedge clk)
    begin : Counter_Limited_process
      if (rst_n == 1'b0) begin
        Counter_Limited_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Counter_Limited_out1 <= count_value;
        end
      end
    end
  assign Constant_out1 = 16'b0000000000000000;
  assign Relational_Operator_out1 = Counter_Limited_out1 == Constant_out1;
  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7199
  assign count_step_1 = 16'b0000000000000001;
  assign count_from_2 = 16'b0000000000000000;
  assign count_1 = HDL_Counter1_out1 + count_step_1;
  assign need_to_wrap = HDL_Counter1_out1 == 16'b0001110000011111;
  assign count_value_1 = (need_to_wrap == 1'b0 ? count_1 :
              count_from_2);
  assign count_2 = (Relational_Operator_out1 == 1'b0 ? HDL_Counter1_out1 :
              count_value_1);
  always @(posedge clk)
    begin : HDL_Counter1_process
      if (rst_n == 1'b0) begin
        HDL_Counter1_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter1_out1 <= count_2;
        end
      end
    end
  assign Constant4_out1 = 16'b0000000000000000;
  assign Relational_Operator2_out1 = HDL_Counter1_out1 == Constant4_out1;
  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step_2 = 8'b00000001;
  assign count_from_3 = 8'b00000000;
  assign count_3 = HDL_Counter_out1 + count_step_2;
  assign need_to_wrap_1 = HDL_Counter_out1 == 8'b11111111;
  assign count_value_2 = (need_to_wrap_1 == 1'b0 ? count_3 :
              count_from_3);
  assign count_4 = (Relational_Operator2_out1 == 1'b0 ? HDL_Counter_out1 :
              count_value_2);
  always @(posedge clk)
    begin : HDL_Counter_process
      if (rst_n == 1'b0) begin
        HDL_Counter_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= count_4;
        end
      end
    end
  SinglePortRAM_generic #(.AddrWidth(8),
                          .DataWidth(8),
                          .NumCols(8),
                          .ColWidth(1)
                          )
                        u_Single_Port_RAM_System (.clk(clk),
                                                  .enb(enb),
                                                  .din(Constant1_out1),
                                                  .addr(HDL_Counter_out1),
                                                  .we(Constant1_out1),
                                                  .dout(Single_Port_RAM_System_out1)
                                                  );
  SinglePortRAM_generic_AsyncRead #(.AddrWidth(8),
                                    .DataWidth(32),
                                    .NumCols(32),
                                    .ColWidth(1)
                                    )
                                  u_Single_Port_RAM_System1 (.clk(clk),
                                                             .enb(enb),
                                                             .din(Constant2_out1),
                                                             .addr(Single_Port_RAM_System_out1),
                                                             .we(Constant2_out1),
                                                             .dout(Single_Port_RAM_System1_out1)
                                                             );
  assign NCO_VLD_out1 = 1'b1;
  NCO u_NCO (.clk(clk),
             .rst_n(rst_n),
             .enb(enb),
             .inc(Single_Port_RAM_System1_out1),  // uint32
             .validIn(NCO_VLD_out1),
             .sine(NCO_out1),  // sfix16_En15
             .validOut(NCO_out2)
             );
  always @(posedge clk)
    begin : HwModeRegister1_process
      if (rst_n == 1'b0) begin
        NCO_out1_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          NCO_out1_1 <= NCO_out1;
        end
      end
    end

  assign Gain2_mul_temp = kconst_1 * NCO_out1_1;
  assign Gain2_out1 = Gain2_mul_temp[30:15];
  always @(posedge clk)
    begin : PipelineRegister_process
      if (rst_n == 1'b0) begin
        Gain2_out1_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Gain2_out1_1 <= Gain2_out1;
        end
      end
    end

  assign SIGNAL = Gain2_out1_1;

  assign VLD = NCO_out2;

endmodule  // Painter

