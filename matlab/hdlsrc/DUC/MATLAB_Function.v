// -------------------------------------------------------------
// 
// File Name: hdlsrc\DUC\MATLAB_Function.v
// Created: 2025-03-11 16:47:33
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: MATLAB_Function
// Source Path: DUC/Wave_Source/MATLAB Function
// Hierarchy Level: 1
// Model version: 3.64
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module MATLAB_Function
          (clk,
           rst_n,
           enb,
           restart,
           norm_out);


  input   clk;
  input   rst_n;
  input   enb;
  input   restart;
  output  signed [15:0] norm_out;  // sfix16_En15


  wire stateControl_1;
  reg  stateControl_2;
  wire enb_gated;
  reg signed [15:0] norm_out_1;  // sfix16_En15
  reg [31:0] count;  // uint32
  reg  restart_prev;
  reg [31:0] count_next;  // uint32
  reg  restart_prev_next;
  reg signed [15:0] norm_out_last_value;  // sfix16_En15
  reg signed [31:0] z;  // uint32
  reg [31:0] count_temp;  // uint32
  reg [31:0] div_temp;  // ufix32
  reg [32:0] add_temp;  // ufix33
  reg [31:0] sub_cast;  // uint32
  reg [31:0] cast;  // uint32
  reg [31:0] t_0;  // uint32
  reg [63:0] mul_temp;  // ufix64
  reg [32:0] t_1;  // ufix33


  assign stateControl_1 = 1'b1;

  always @(posedge clk)
    begin : delayMatch_process
      if (rst_n == 1'b0) begin
        stateControl_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          stateControl_2 <= stateControl_1;
        end
      end
    end

  assign enb_gated = stateControl_2 && enb;

  always @(posedge clk)
    begin : MATLAB_Function_1_process
      if (rst_n == 1'b0) begin
        count <= 32'd0;
        restart_prev <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          count <= count_next;
          restart_prev <= restart_prev_next;
        end
      end
    end

  always @(count, restart, restart_prev) begin
    add_temp = 33'h000000000;
    t_1 = 33'h000000000;
    //MATLAB Function 'Wave_Source/MATLAB Function'
    // counter_normalized - 计数器归一化输出函数（HDL Coder 兼容）
    // 功能描述：
    //   每个时钟周期调用一次该函数，计数器从 0 开始自增，
    //   当计数到最大值 10000000 时停止递增（保持该值）。
    //   当检测到 restart 信号的上升沿时，计数器清零重新开始计数。
    //   输出将计数值归一化（count/10000000），以 Q1.15 格式输出。
    // 输入:
    //   restart - 重置信号，逻辑型（true/false），在上升沿时清零计数器
    // 输出:
    //   norm_out - 归一化的计数器输出（Q1.15 固定点格式：16 位有符号、15 位小数）
    // 说明：
    //   本函数适用于 HDL Coder，每个时钟周期调用一次。
    // 确保 restart 为逻辑型
    // 定义最大计数值
    // persistent 变量用于保存状态
    // 检测 restart 信号的上升沿（由低到高）
    if (restart && ( ! restart_prev)) begin
      count_temp = 32'd0;
    end
    else if (count < 32'd10000000) begin
      t_1 = {1'b0, count};
      add_temp = t_1 + 33'h000000001;
      if (add_temp[32] != 1'b0) begin
        count_temp = 32'b11111111111111111111111111111111;
      end
      else begin
        count_temp = add_temp[31:0];
      end
    end
    else begin
      count_temp = 32'd10000000;
    end
    // 归一化计数值： count/10000000
    // 将结果转换为 Q1.15 格式（16 位有符号，15 位小数）
    div_temp = count_temp / 32'd10000000;
    z = div_temp;
    t_0 = z;
    mul_temp = t_0 * 32'd10000000;
    sub_cast = mul_temp[31:0];
    if ((count_temp - sub_cast) >= 32'd5000000) begin
      z = z + 32'sd1;
    end
    // 更新上一次 restart 状态
    restart_prev_next = restart;
    cast = z;
    if (cast != 32'b00000000000000000000000000000000) begin
      norm_out_1 = 16'sb0111111111111111;
    end
    else begin
      norm_out_1 = {cast[0], 15'b000000000000000};
    end
    count_next = count_temp;
  end
  always @(posedge clk)
    begin : out0_bypass_process
      if (rst_n == 1'b0) begin
        norm_out_last_value <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated) begin
          norm_out_last_value <= norm_out;
        end
      end
    end

  assign norm_out = (stateControl_2 == 1'b0 ? norm_out_last_value :
              norm_out_1);

endmodule  // MATLAB_Function

