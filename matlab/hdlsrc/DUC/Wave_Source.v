// -------------------------------------------------------------
// 
// File Name: hdlsrc\DUC\Wave_Source.v
// Created: 2025-03-11 17:04:39
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 8.33333e-09
// Target subsystem base rate: 8.33333e-09
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        8.33333e-09
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Sine_Out                      ce_out        8.33333e-09
// VLD                           ce_out        8.33333e-09
// Fade_Out                      ce_out        8.33333e-09
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Wave_Source
// Source Path: DUC/Wave_Source
// Hierarchy Level: 0
// Model version: 3.64
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Wave_Source
          (clk,
           rst_n,
           clk_enable,
           phInc,
           Fade_in,
           ce_out,
           Sine_Out,
           VLD,
           Fade_Out);


  input   clk;
  input   rst_n;
  input   clk_enable;
  input   [31:0] phInc;  // uint32
  input   signed [15:0] Fade_in;  // sfix16_En15
  output  ce_out;
  output  signed [15:0] Sine_Out;  // sfix16_En15
  output  VLD;
  output  signed [15:0] Fade_Out;  // sfix16_En15


  wire enb;
  reg [31:0] phInc_1;  // uint32
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from_1;  // uint16
  reg [15:0] Counter_Limited_out1;  // uint16
  wire [15:0] count;  // uint16
  wire needToWrap;
  wire [15:0] count_value;  // uint16
  wire [15:0] Constant_out1;  // uint16
  wire Relational_Operator_out1;
  reg  Relational_Operator_out1_1;
  wire signed [15:0] NCO_out1;  // sfix16_En15
  wire NCO_out2;
  reg signed [15:0] NCO_out1_1;  // sfix16_En15
  reg signed [15:0] reduced_reg [0:1];  // sfix16 [2]
  wire signed [15:0] reduced_reg_next [0:1];  // sfix16_En15 [2]
  wire signed [15:0] NCO_out1_2;  // sfix16_En15
  reg  [2:0] delayMatch2_reg;  // ufix1 [3]
  wire NCO_out2_1;
  reg signed [15:0] HwModeRegister1_reg [0:1];  // sfix16 [2]
  wire signed [15:0] HwModeRegister1_reg_next [0:1];  // sfix16_En15 [2]
  wire signed [15:0] Fade_in_1;  // sfix16_En15
  wire signed [31:0] Product_mul_temp;  // sfix32_En30
  wire signed [15:0] Product_out1;  // sfix16_En15
  reg signed [15:0] out_2_pipe_reg [0:1];  // sfix16 [2]
  wire signed [15:0] out_2_pipe_reg_next [0:1];  // sfix16_En15 [2]
  wire signed [15:0] Product_out1_1;  // sfix16_En15
  reg signed [31:0] reduced_t_0_0;  // int32
  reg signed [31:0] reduced_t_1;  // int32
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] out_2_pipe_t_0_0;  // int32
  reg signed [31:0] out_2_pipe_t_1;  // int32


  assign enb = clk_enable;

  always @(posedge clk)
    begin : in_0_pipe_process
      if (rst_n == 1'b0) begin
        phInc_1 <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          phInc_1 <= phInc;
        end
      end
    end

  assign count_step = 16'b0000000000000001;
  assign count_from_1 = 16'b0000000000000000;
  assign count = Counter_Limited_out1 + count_step;
  assign needToWrap = Counter_Limited_out1 >= 16'b0000100111000011;
  assign count_value = (needToWrap == 1'b0 ? count :
              count_from_1);
  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2499
  always @(posedge clk)
    begin : Counter_Limited_process
      if (rst_n == 1'b0) begin
        Counter_Limited_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Counter_Limited_out1 <= count_value;
        end
      end
    end
  assign Constant_out1 = 16'b0000000000000000;
  assign Relational_Operator_out1 = Counter_Limited_out1 == Constant_out1;
  always @(posedge clk)
    begin : delayMatch_process
      if (rst_n == 1'b0) begin
        Relational_Operator_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Relational_Operator_out1_1 <= Relational_Operator_out1;
        end
      end
    end

  NCO u_NCO (.clk(clk),
             .rst_n(rst_n),
             .enb(clk_enable),
             .inc(phInc_1),  // uint32
             .validIn(Relational_Operator_out1_1),
             .sine(NCO_out1),  // sfix16_En15
             .validOut(NCO_out2)
             );
  always @(posedge clk)
    begin : reduced_process
      if (rst_n == 1'b0) begin
        NCO_out1_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          NCO_out1_1 <= NCO_out1;
        end
      end
    end

  always @(posedge clk)
    begin : reduced_1_process
      if (rst_n == 1'b0) begin
        for(reduced_t_1 = 32'sd0; reduced_t_1 <= 32'sd1; reduced_t_1 = reduced_t_1 + 32'sd1) begin
          reduced_reg[reduced_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(reduced_t_0_0 = 32'sd0; reduced_t_0_0 <= 32'sd1; reduced_t_0_0 = reduced_t_0_0 + 32'sd1) begin
            reduced_reg[reduced_t_0_0] <= reduced_reg_next[reduced_t_0_0];
          end
        end
      end
    end

  assign NCO_out1_2 = reduced_reg[1];
  assign reduced_reg_next[0] = NCO_out1_1;
  assign reduced_reg_next[1] = reduced_reg[0];

  assign Sine_Out = NCO_out1_2;

  always @(posedge clk)
    begin : delayMatch2_process
      if (rst_n == 1'b0) begin
        delayMatch2_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= NCO_out2;
          delayMatch2_reg[32'sd2:32'sd1] <= delayMatch2_reg[32'sd1:32'sd0];
        end
      end
    end

  assign NCO_out2_1 = delayMatch2_reg[2];

  assign VLD = NCO_out2_1;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (rst_n == 1'b0) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd1; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          HwModeRegister1_reg[HwModeRegister1_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd1; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            HwModeRegister1_reg[HwModeRegister1_t_0_0] <= HwModeRegister1_reg_next[HwModeRegister1_t_0_0];
          end
        end
      end
    end

  assign Fade_in_1 = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[0] = Fade_in;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];

  assign Product_mul_temp = NCO_out1_1 * Fade_in_1;
  assign Product_out1 = Product_mul_temp[30:15];
  always @(posedge clk)
    begin : out_2_pipe_process
      if (rst_n == 1'b0) begin
        for(out_2_pipe_t_1 = 32'sd0; out_2_pipe_t_1 <= 32'sd1; out_2_pipe_t_1 = out_2_pipe_t_1 + 32'sd1) begin
          out_2_pipe_reg[out_2_pipe_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(out_2_pipe_t_0_0 = 32'sd0; out_2_pipe_t_0_0 <= 32'sd1; out_2_pipe_t_0_0 = out_2_pipe_t_0_0 + 32'sd1) begin
            out_2_pipe_reg[out_2_pipe_t_0_0] <= out_2_pipe_reg_next[out_2_pipe_t_0_0];
          end
        end
      end
    end

  assign Product_out1_1 = out_2_pipe_reg[1];
  assign out_2_pipe_reg_next[0] = Product_out1;
  assign out_2_pipe_reg_next[1] = out_2_pipe_reg[0];

  assign Fade_Out = Product_out1_1;

  assign ce_out = clk_enable;

endmodule  // Wave_Source

